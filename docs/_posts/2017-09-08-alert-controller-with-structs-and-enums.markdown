---
layout: post
title:  "Structs and enums in abstraction (UIAlertController)"
date:   2017-09-08 16:38:56 +0200
categories: articles

---


How can we abstract `UIAlertController` and interaction with it with the help of value types? It is simpler than one might think. 


First things first, let's understand what this class represents from this diagram.

![alert-controller](/images/alertcontroller.png){:class="img-responsive"}

`UIAlertController` has a title and a message which hold static values, the ones we pass at their creation. `UIAlertController` also contains a set of children that are there for user interaction. They support events and their values can change anytime. In this implementation we create a single interface for textfield and button types. We are going to pass them an input and expect an output from them. 
Since `actionSheet:UIAlertActionStyle` type doesn't support textfields, we omit that and concentrate only on `alert:UIAlertActionStyle` types.

![alert-controller](/images/alertcontroller-highlighted.png){:class="img-responsive"}

Now to the abstraction. We can create a single type to define both the button and the textfield. 

{% highlight swift %}
enum AlertItemType {
    case button(String) // title for the given button
    case textField(String) // input text for the given textfield
}
{% endhighlight %}


and place it inside a struct. We call this type `AlertItem`.

{% highlight swift %}
struct AlertItem {
  enum AlertItemType {
    case button(String)
    case textField(String)
  }
  let type:AlertItemType
  let handler:(String?)->Void
}

{% endhighlight %}

The whole alert view is then represented by this struct. 
{% highlight swift %}
struct Alert {
  let title:String
  let message:String
  let items:[AlertItem]
}
{% endhighlight %}


Interesting thing is that we can pass both the button and textfield a `String` input and expect a `String` output. For button, this plays out as button's title (input), and nil (output). For textfield, it is textfield's text or placeholder (input), and the text generated by the user (output). Wait, but `UIAlertController` doesn't provide a handler with a textfield like it does with a button.
We do that on our own, and abstract it through a "parser" object, which will in return call our handler at every character-change.

![alert-controller](/images/interaction.png){:class="img-responsive"}


{% highlight swift %}

class Parser:NSObject {
    // keep reference to the textfields being presented to the user
    private var textControls = [ UITextField: (String?)->Void ]()
    
    public func evaluate(_ alert:Alert)->UIAlertController{
        // generate UIAlertController instance from the configuration object
        let controller = UIAlertController(title: alert.title, message: alert.message, preferredStyle: .alert)
        alert.items.map({ item in
            switch item.type {
            case .button(let input):
                let action = UIAlertAction(title: input, style: .default, handler: { (action:UIAlertAction) in
                    item.handler(nil)
                })
                controller.addAction(action)
                
            case .textField(let input):
                controller.addTextField { (textField: UITextField!) in
                    textField.placeholder = input
                    // observe user-typing event
                    textField.addTarget(self, action: #selector(self.textFieldDidChange(_:)), for: .editingChanged)
                    // keep reference to the textfield and its handler to invoke later
                    self.textControls[textField] = item.handler
                }
            }
        })
        // ready to be presented on-screen
        return controller
    }
    
    func textFieldDidChange(_ textField: UITextField) {
        // get the correct handler, and invoke
        if let handler = self.textControls
            .filter({ key, _ in textField == key})
            .map( { _, value in value })
            .first {
            handler(textField.text)
        }
    }
}
{% endhighlight %}
We can use it then like this:
{% highlight swift %}

let parser = Parser()
var username:String?
var password:String?
let usernameItem = AlertItem(type: .textField("username")) { output in
    username = output
}
let passwordItem = AlertItem(type: .textField("password")) { output in
    password = output
}
let okItem = AlertItem(type: .button("Ok")) { _ in
    // handle login 
    print("values are: [\(username) - \(password)]")
}
let cancelItem = AlertItem(type: .button("Cancel")) { _ in /* cancelled */}
let alert = Alert(title: "Welcome", message: "Please login", items: [usernameItem, passwordItem, okItem, cancelItem])
let alertController = parser.evaluate(alert)
myViewController.present(alertController, animated: true, completion: nil)

{% endhighlight %}

It would appear on-screen like this:


![alert-controller](/images/login.png){:class="img-responsive"}

This simple implementation took 2 structs, 1 enums and 1 class in total. And since responsibilities are separated we can test them as well.


The complete code you can find <a href="https://github.com/rsardek/Alertview">here</a>.

